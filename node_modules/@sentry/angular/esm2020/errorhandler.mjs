import { HttpErrorResponse } from '@angular/common/http';
import { Inject, Injectable } from '@angular/core';
import * as Sentry from '@sentry/browser';
import { consoleSandbox, isString } from '@sentry/utils';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
// https://github.com/angular/angular/blob/master/packages/core/src/util/errors.ts
function tryToUnwrapZonejsError(error) {
    // TODO: once Angular14 is the minimum requirement ERROR_ORIGINAL_ERROR and
    //  getOriginalError from error.ts can be used directly.
    return error && error.ngOriginalError
        ? error.ngOriginalError
        : error;
}
function extractHttpModuleError(error) {
    // The `error` property of http exception can be either an `Error` object, which we can use directly...
    if (isErrorOrErrorLikeObject(error.error)) {
        return error.error;
    }
    // ... or an`ErrorEvent`, which can provide us with the message but no stack...
    // guarding `ErrorEvent` against `undefined` as it's not defined in Node environments
    if (typeof ErrorEvent !== 'undefined' && error.error instanceof ErrorEvent && error.error.message) {
        return error.error.message;
    }
    // ...or the request body itself, which we can use as a message instead.
    if (typeof error.error === 'string') {
        return `Server returned code ${error.status} with body "${error.error}"`;
    }
    // If we don't have any detailed information, fallback to the request message itself.
    return error.message;
}
function isErrorOrErrorLikeObject(value) {
    if (value instanceof Error) {
        return true;
    }
    if (value === null || typeof value !== 'object') {
        return false;
    }
    const candidate = value;
    return (isString(candidate.name) &&
        isString(candidate.message) &&
        (undefined === candidate.stack || isString(candidate.stack)));
}
/**
 * Implementation of Angular's ErrorHandler provider that can be used as a drop-in replacement for the stock one.
 */
class SentryErrorHandler {
    constructor(options) {
        this._options = {
            logErrors: true,
            ...options,
        };
    }
    /**
     * Method executed when the injector is destroyed.
     */
    ngOnDestroy() {
        if (this._removeAfterSendEventListener) {
            this._removeAfterSendEventListener();
        }
    }
    /**
     * Method called for every value captured through the ErrorHandler
     */
    handleError(error) {
        const extractedError = this._extractError(error) || 'Handled unknown error';
        // Capture handled exception and send it to Sentry.
        const eventId = runOutsideAngular(() => Sentry.captureException(extractedError, {
            mechanism: { type: 'angular', handled: false },
        }));
        // When in development mode, log the error to console for immediate feedback.
        if (this._options.logErrors) {
            // eslint-disable-next-line no-console
            consoleSandbox(() => console.error(extractedError));
        }
        // Optionally show user dialog to provide details on what happened.
        if (this._options.showDialog) {
            const client = Sentry.getClient();
            if (client && !this._removeAfterSendEventListener) {
                this._removeAfterSendEventListener = client.on('afterSendEvent', (event) => {
                    if (!event.type && event.event_id) {
                        runOutsideAngular(() => {
                            Sentry.showReportDialog({ ...this._options.dialogOptions, eventId: event.event_id });
                        });
                    }
                });
            }
            else if (!client) {
                runOutsideAngular(() => {
                    Sentry.showReportDialog({ ...this._options.dialogOptions, eventId });
                });
            }
        }
    }
    /**
     * Used to pull a desired value that will be used to capture an event out of the raw value captured by ErrorHandler.
     */
    _extractError(error) {
        // Allow custom overrides of extracting function
        if (this._options.extractor) {
            const defaultExtractor = this._defaultExtractor.bind(this);
            return this._options.extractor(error, defaultExtractor);
        }
        return this._defaultExtractor(error);
    }
    /**
     * Default implementation of error extraction that handles default error wrapping, HTTP responses, ErrorEvent and few other known cases.
     */
    _defaultExtractor(errorCandidate) {
        const error = tryToUnwrapZonejsError(errorCandidate);
        // If it's http module error, extract as much information from it as we can.
        if (error instanceof HttpErrorResponse) {
            return extractHttpModuleError(error);
        }
        // We can handle messages and Error objects directly.
        if (typeof error === 'string' || isErrorOrErrorLikeObject(error)) {
            return error;
        }
        // Nothing was extracted, fallback to default error message.
        return null;
    }
}
SentryErrorHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SentryErrorHandler, deps: [{ token: 'errorHandlerOptions' }], target: i0.ɵɵFactoryTarget.Injectable });
SentryErrorHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SentryErrorHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SentryErrorHandler, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['errorHandlerOptions']
                }] }]; } });
/**
 * Factory function that creates an instance of a preconfigured ErrorHandler provider.
 */
function createErrorHandler(config) {
    return new SentryErrorHandler(config);
}
export { createErrorHandler, SentryErrorHandler };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JoYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Vycm9yaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV6RCxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEtBQUssTUFBTSxNQUFNLGlCQUFpQixDQUFDO0FBRzFDLE9BQU8sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXpELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFFBQVEsQ0FBQzs7QUFpQjNDLGtGQUFrRjtBQUNsRixTQUFTLHNCQUFzQixDQUFDLEtBQWM7SUFDNUMsMkVBQTJFO0lBQzNFLHdEQUF3RDtJQUN4RCxPQUFPLEtBQUssSUFBSyxLQUFvQyxDQUFDLGVBQWU7UUFDbkUsQ0FBQyxDQUFFLEtBQW9DLENBQUMsZUFBZTtRQUN2RCxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ1osQ0FBQztBQUVELFNBQVMsc0JBQXNCLENBQUMsS0FBd0I7SUFDdEQsdUdBQXVHO0lBQ3ZHLElBQUksd0JBQXdCLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3pDLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQztLQUNwQjtJQUVELCtFQUErRTtJQUMvRSxxRkFBcUY7SUFDckYsSUFBSSxPQUFPLFVBQVUsS0FBSyxXQUFXLElBQUksS0FBSyxDQUFDLEtBQUssWUFBWSxVQUFVLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUU7UUFDakcsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztLQUM1QjtJQUVELHdFQUF3RTtJQUN4RSxJQUFJLE9BQU8sS0FBSyxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDbkMsT0FBTyx3QkFBd0IsS0FBSyxDQUFDLE1B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c2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgdHlwZSB7IEVycm9ySGFuZGxlciBhcyBBbmd1bGFyRXJyb3JIYW5kbGVyLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgU2VudHJ5IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XG5pbXBvcnQgdHlwZSB7IFJlcG9ydERpYWxvZ09wdGlvbnMgfSBmcm9tICdAc2VudHJ5L2Jyb3dzZXInO1xuaW1wb3J0IHR5cGUgeyBFdmVudCB9IGZyb20gJ0BzZW50cnkvdHlwZXMnO1xuaW1wb3J0IHsgY29uc29sZVNhbmRib3gsIGlzU3RyaW5nIH0gZnJvbSAnQHNlbnRyeS91dGlscyc7XG5cbmltcG9ydCB7IHJ1bk91dHNpZGVBbmd1bGFyIH0gZnJvbSAnLi96b25lJztcblxuLyoqXG4gKiBPcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoZSBiZWhhdmlvciBvZiB0aGUgQW5ndWxhciBFcnJvckhhbmRsZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JIYW5kbGVyT3B0aW9ucyB7XG4gIGxvZ0Vycm9ycz86IGJvb2xlYW47XG4gIHNob3dEaWFsb2c/OiBib29sZWFuO1xuICBkaWFsb2dPcHRpb25zPzogUmVwb3J0RGlhbG9nT3B0aW9ucztcbiAgLyoqXG4gICAqIEN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiBlcnJvciBleHRyYWN0aW9uIGZyb20gdGhlIHJhdyB2YWx1ZSBjYXB0dXJlZCBieSB0aGUgQW5ndWxhci5cbiAgICogQHBhcmFtIGVycm9yIFZhbHVlIGNhcHR1cmVkIGJ5IEFuZ3VsYXIncyBFcnJvckhhbmRsZXIgcHJvdmlkZXJcbiAgICogQHBhcmFtIGRlZmF1bHRFeHRyYWN0b3IgRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGFzIHRoZSBmYWxsYmFjayBpbiBjYXNlIG9mIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZXh0cmFjdG9yPyhlcnJvcjogdW5rbm93biwgZGVmYXVsdEV4dHJhY3RvcjogKGVycm9yOiB1bmtub3duKSA9PiB1bmtub3duKTogdW5rbm93bjtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL21hc3Rlci9wYWNrYWdlcy9jb3JlL3NyYy91dGlsL2Vycm9ycy50c1xuZnVuY3Rpb24gdHJ5VG9VbndyYXBab25lanNFcnJvcihlcnJvcjogdW5rbm93bik6IHVua25vd24gfCBFcnJvciB7XG4gIC8vIFRPRE86IG9uY2UgQW5ndWxhcjE0IGlzIHRoZSBtaW5pbXVtIHJlcXVpcmVtZW50IEVSUk9SX09SSUdJTkFMX0VSUk9SIGFuZFxuICAvLyAgZ2V0T3JpZ2luYWxFcnJvciBmcm9tIGVycm9yLnRzIGNhbiBiZSB1c2VkIGRpcmVjdGx5LlxuICByZXR1cm4gZXJyb3IgJiYgKGVycm9yIGFzIHsgbmdPcmlnaW5hbEVycm9yOiBFcnJvciB9KS5uZ09yaWdpbmFsRXJyb3JcbiAgICA/IChlcnJvciBhcyB7IG5nT3JpZ2luYWxFcnJvcjogRXJyb3IgfSkubmdPcmlnaW5hbEVycm9yXG4gICAgOiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEh0dHBNb2R1bGVFcnJvcihlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UpOiBzdHJpbmcgfCBFcnJvciB7XG4gIC8vIFRoZSBgZXJyb3JgIHByb3BlcnR5IG9mIGh0dHAgZXhjZXB0aW9uIGNhbiBiZSBlaXRoZXIgYW4gYEVycm9yYCBvYmplY3QsIHdoaWNoIHdlIGNhbiB1c2UgZGlyZWN0bHkuLi5cbiAgaWYgKGlzRXJyb3JPckVycm9yTGlrZU9iamVjdChlcnJvci5lcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3IuZXJyb3I7XG4gIH1cblxuICAvLyAuLi4gb3IgYW5gRXJyb3JFdmVudGAsIHdoaWNoIGNhbiBwcm92aWRlIHVzIHdpdGggdGhlIG1lc3NhZ2UgYnV0IG5vIHN0YWNrLi4uXG4gIC8vIGd1YXJkaW5nIGBFcnJvckV2ZW50YCBhZ2FpbnN0IGB1bmRlZmluZWRgIGFzIGl0J3Mgbm90IGRlZmluZWQgaW4gTm9kZSBlbnZpcm9ubWVudHNcbiAgaWYgKHR5cGVvZiBFcnJvckV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBlcnJvci5lcnJvciBpbnN0YW5jZW9mIEVycm9yRXZlbnQgJiYgZXJyb3IuZXJyb3IubWVzc2FnZSkge1xuICAgIHJldHVybiBlcnJvci5lcnJvci5tZXNzYWdlO1xuICB9XG5cbiAgLy8gLi4ub3IgdGhlIHJlcXVlc3QgYm9keSBpdHNlbGYsIHdoaWNoIHdlIGNhbiB1c2UgYXMgYSBtZXNzYWdlIGluc3RlYWQuXG4gIGlmICh0eXBlb2YgZXJyb3IuZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGBTZXJ2ZXIgcmV0dXJuZWQgY29kZSAke2Vycm9yLnN0YXR1c30gd2l0aCBib2R5IFwiJHtlcnJvci5lcnJvcn1cImA7XG4gIH1cblxuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgZmFsbGJhY2sgdG8gdGhlIHJlcXVlc3QgbWVzc2FnZSBpdHNlbGYuXG4gIHJldHVybiBlcnJvci5tZXNzYWdlO1xufVxuXG50eXBlIEVycm9yQ2FuZGlkYXRlID0ge1xuICBuYW1lPzogdW5rbm93bjtcbiAgbWVzc2FnZT86IHVua25vd247XG4gIHN0YWNrPzogdW5rbm93bjtcbn07XG5cbmZ1bmN0aW9uIGlzRXJyb3JPckVycm9yTGlrZU9iamVjdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWUgYXMgRXJyb3JDYW5kaWRhdGU7XG5cbiAgcmV0dXJuIChcbiAgICBpc1N0cmluZyhjYW5kaWRhdGUubmFtZSkgJiZcbiAgICBpc1N0cmluZyhjYW5kaWRhdGUubWVzc2FnZSkgJiZcbiAgICAodW5kZWZpbmVkID09PSBjYW5kaWRhdGUuc3RhY2sgfHwgaXNTdHJpbmcoY2FuZGlkYXRlLnN0YWNrKSlcbiAgKTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBBbmd1bGFyJ3MgRXJyb3JIYW5kbGVyIHByb3ZpZGVyIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciB0aGUgc3RvY2sgb25lLlxuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuY2xhc3MgU2VudHJ5RXJyb3JIYW5kbGVyIGltcGxlbWVudHMgQW5ndWxhckVycm9ySGFuZGxlciwgT25EZXN0cm95IHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9vcHRpb25zOiBFcnJvckhhbmRsZXJPcHRpb25zO1xuXG4gIC8qKiBUaGUgY2xlYW51cCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aGVuIHRoZSBpbmplY3RvciBpcyBkZXN0cm95ZWQuICovXG4gIHByaXZhdGUgX3JlbW92ZUFmdGVyU2VuZEV2ZW50TGlzdGVuZXI/OiAoKSA9PiB2b2lkO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihASW5qZWN0KCdlcnJvckhhbmRsZXJPcHRpb25zJykgb3B0aW9ucz86IEVycm9ySGFuZGxlck9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgbG9nRXJyb3JzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBleGVjdXRlZCB3aGVuIHRoZSBpbmplY3RvciBpcyBkZXN0cm95ZWQuXG4gICAqL1xuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3JlbW92ZUFmdGVyU2VuZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUFmdGVyU2VuZEV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGNhbGxlZCBmb3IgZXZlcnkgdmFsdWUgY2FwdHVyZWQgdGhyb3VnaCB0aGUgRXJyb3JIYW5kbGVyXG4gICAqL1xuICBwdWJsaWMgaGFuZGxlRXJyb3IoZXJyb3I6IHVua25vd24pOiB2b2lkIHtcbiAgICBjb25zdCBleHRyYWN0ZWRFcnJvciA9IHRoaXMuX2V4dHJhY3RFcnJvcihlcnJvcikgfHwgJ0hhbmRsZWQgdW5rbm93biBlcnJvcic7XG5cbiAgICAvLyBDYXB0dXJlIGhhbmRsZWQgZXhjZXB0aW9uIGFuZCBzZW5kIGl0IHRvIFNlbnRyeS5cbiAgICBjb25zdCBldmVudElkID0gcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgIFNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKGV4dHJhY3RlZEVycm9yLCB7XG4gICAgICAgIG1lY2hhbmlzbTogeyB0eXBlOiAnYW5ndWxhcicsIGhhbmRsZWQ6IGZhbHNlIH0sXG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgLy8gV2hlbiBpbiBkZXZlbG9wbWVudCBtb2RlLCBsb2cgdGhlIGVycm9yIHRvIGNvbnNvbGUgZm9yIGltbWVkaWF0ZSBmZWVkYmFjay5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5sb2dFcnJvcnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlU2FuZGJveCgoKSA9PiBjb25zb2xlLmVycm9yKGV4dHJhY3RlZEVycm9yKSk7XG4gICAgfVxuXG4gICAgLy8gT3B0aW9uYWxseSBzaG93IHVzZXIgZGlhbG9nIHRvIHByb3ZpZGUgZGV0YWlscyBvbiB3aGF0IGhhcHBlbmVkLlxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNob3dEaWFsb2cpIHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IFNlbnRyeS5nZXRDbGllbnQoKTtcblxuICAgICAgaWYgKGNsaWVudCAmJiAhdGhpcy5fcmVtb3ZlQWZ0ZXJTZW5kRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVBZnRlclNlbmRFdmVudExpc3RlbmVyID0gY2xpZW50Lm9uKCdhZnRlclNlbmRFdmVudCcsIChldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoIWV2ZW50LnR5cGUgJiYgZXZlbnQuZXZlbnRfaWQpIHtcbiAgICAgICAgICAgIHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgU2VudHJ5LnNob3dSZXBvcnREaWFsb2coeyAuLi50aGlzLl9vcHRpb25zLmRpYWxvZ09wdGlvbnMsIGV2ZW50SWQ6IGV2ZW50LmV2ZW50X2lkIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWNsaWVudCkge1xuICAgICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgU2VudHJ5LnNob3dSZXBvcnREaWFsb2coeyAuLi50aGlzLl9vcHRpb25zLmRpYWxvZ09wdGlvbnMsIGV2ZW50SWQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHB1bGwgYSBkZXNpcmVkIHZhbHVlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNhcHR1cmUgYW4gZXZlbnQgb3V0IG9mIHRoZSByYXcgdmFsdWUgY2FwdHVyZWQgYnkgRXJyb3JIYW5kbGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9leHRyYWN0RXJyb3IoZXJyb3I6IHVua25vd24pOiB1bmtub3duIHtcbiAgICAvLyBBbGxvdyBjdXN0b20gb3ZlcnJpZGVzIG9mIGV4dHJhY3RpbmcgZnVuY3Rpb25cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5leHRyYWN0b3IpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRFeHRyYWN0b3IgPSB0aGlzLl9kZWZhdWx0RXh0cmFjdG9yLmJpbmQodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5leHRyYWN0b3IoZXJyb3IsIGRlZmF1bHRFeHRyYWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0RXh0cmFjdG9yKGVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGVycm9yIGV4dHJhY3Rpb24gdGhhdCBoYW5kbGVzIGRlZmF1bHQgZXJyb3Igd3JhcHBpbmcsIEhUVFAgcmVzcG9uc2VzLCBFcnJvckV2ZW50IGFuZCBmZXcgb3RoZXIga25vd24gY2FzZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2RlZmF1bHRFeHRyYWN0b3IoZXJyb3JDYW5kaWRhdGU6IHVua25vd24pOiB1bmtub3duIHtcbiAgICBjb25zdCBlcnJvciA9IHRyeVRvVW53cmFwWm9uZWpzRXJyb3IoZXJyb3JDYW5kaWRhdGUpO1xuXG4gICAgLy8gSWYgaXQncyBodHRwIG1vZHVsZSBlcnJvciwgZXh0cmFjdCBhcyBtdWNoIGluZm9ybWF0aW9uIGZyb20gaXQgYXMgd2UgY2FuLlxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEh0dHBFcnJvclJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gZXh0cmFjdEh0dHBNb2R1bGVFcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIGhhbmRsZSBtZXNzYWdlcyBhbmQgRXJyb3Igb2JqZWN0cyBkaXJlY3RseS5cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyB8fCBpc0Vycm9yT3JFcnJvckxpa2VPYmplY3QoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gTm90aGluZyB3YXMgZXh0cmFjdGVkLCBmYWxsYmFjayB0byBkZWZhdWx0IGVycm9yIG1lc3NhZ2UuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIHByZWNvbmZpZ3VyZWQgRXJyb3JIYW5kbGVyIHByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFcnJvckhhbmRsZXIoY29uZmlnPzogRXJyb3JIYW5kbGVyT3B0aW9ucyk6IFNlbnRyeUVycm9ySGFuZGxlciB7XG4gIHJldHVybiBuZXcgU2VudHJ5RXJyb3JIYW5kbGVyKGNvbmZpZyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVycm9ySGFuZGxlciwgU2VudHJ5RXJyb3JIYW5kbGVyIH07XG4iXX0=