import { Directive, Injectable, Input, NgModule } from '@angular/core';
// Duplicated import to work around a TypeScript bug where it'd complain that `Router` isn't imported as a type.
// We need to import it as a value to satisfy Angular dependency injection. So:
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { NavigationCancel, NavigationError } from '@angular/router';
import { NavigationEnd, NavigationStart, ResolveEnd } from '@angular/router';
import { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, browserTracingIntegration as originalBrowserTracingIntegration, getActiveSpan, getClient, getCurrentScope, getRootSpan, spanToJSON, startBrowserTracingNavigationSpan, startInactiveSpan, } from '@sentry/browser';
import { logger, stripUrlQueryAndFragment, timestampInSeconds } from '@sentry/utils';
import { Subscription } from 'rxjs';
import { filter, tap } from 'rxjs/operators';
import { ANGULAR_INIT_OP, ANGULAR_OP, ANGULAR_ROUTING_OP } from './constants';
import { IS_DEBUG_BUILD } from './flags';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
let instrumentationInitialized;
/**
 * A custom browser tracing integration for Angular.
 *
 * Use this integration in combination with `TraceService`
 */
export function browserTracingIntegration(options = {}) {
    // If the user opts out to set this up, we just don't initialize this.
    // That way, the TraceService will not actually do anything, functionally disabling this.
    if (options.instrumentNavigation !== false) {
        instrumentationInitialized = true;
    }
    return originalBrowserTracingIntegration({
        ...options,
        instrumentNavigation: false,
    });
}
/**
 * This function is extracted to make unit testing easier.
 */
export function _updateSpanAttributesForParametrizedUrl(route, span) {
    const attributes = (span && spanToJSON(span).data) || {};
    if (span && attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'url') {
        span.updateName(route);
        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');
        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, `auto.${spanToJSON(span).op}.angular`);
    }
}
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export class TraceService {
    constructor(_router) {
        this._router = _router;
        this.navStart$ = this._router.events.pipe(filter((event) => event instanceof NavigationStart), tap(navigationEvent => {
            if (!instrumentationInitialized) {
                IS_DEBUG_BUILD &&
                    logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            if (this._routingSpan) {
                this._routingSpan.end();
                this._routingSpan = null;
            }
            const client = getClient();
            const strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);
            if (client) {
                // see comment in `_isPageloadOngoing` for rationale
                if (!this._isPageloadOngoing()) {
                    runOutsideAngular(() => {
                        startBrowserTracingNavigationSpan(client, {
                            name: strippedUrl,
                            attributes: {
                                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.angular',
                                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                            },
                        });
                    });
                }
                else {
                    // The first time we end up here, we set the pageload flag to false
                    // Subsequent navigations are going to get their own navigation root span
                    // even if the pageload root span is still ongoing.
                    this._pageloadOngoing = false;
                }
                this._routingSpan =
                    runOutsideAngular(() => startInactiveSpan({
                        name: `${navigationEvent.url}`,
                        op: ANGULAR_ROUTING_OP,
                        attributes: {
                            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular',
                            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                            url: strippedUrl,
                            ...(navigationEvent.navigationTrigger && {
                                navigationTrigger: navigationEvent.navigationTrigger,
                            }),
                        },
                    })) || null;
                return;
            }
        }));
        // The ResolveEnd event is fired when the Angular router has resolved the URL and
        // the parameter<->value mapping. It holds the new resolved router state with
        // the mapping and the new URL.
        // Only After this event, the route is activated, meaning that the transaction
        // can be updated with the parameterized route name before e.g. the route's root
        // component is initialized. This should be early enough before outgoing requests
        // are made from the new route, with the exceptions of requests being made during
        // a navigation.
        this.resEnd$ = this._router.events.pipe(filter((event) => event instanceof ResolveEnd), tap(event => {
            const route = getParameterizedRouteFromSnapshot(event.state.root);
            if (route) {
                getCurrentScope().setTransactionName(route);
            }
            const activeSpan = getActiveSpan();
            const rootSpan = activeSpan && getRootSpan(activeSpan);
            _updateSpanAttributesForParametrizedUrl(route, rootSpan);
        }));
        this.navEnd$ = this._router.events.pipe(filter(event => event instanceof NavigationEnd || event instanceof NavigationCancel || event instanceof NavigationError), tap(() => {
            if (this._routingSpan) {
                runOutsideAngular(() => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this._routingSpan.end();
                });
                this._routingSpan = null;
            }
        }));
        this._routingSpan = null;
        this._pageloadOngoing = true;
        this._subscription = new Subscription();
        this._subscription.add(this.navStart$.subscribe());
        this._subscription.add(this.resEnd$.subscribe());
        this._subscription.add(this.navEnd$.subscribe());
    }
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
    /**
     * We only _avoid_ creating a navigation root span in one case:
     *
     * There is an ongoing pageload span AND the router didn't yet emit the first navigation start event
     *
     * The first navigation start event will create the child routing span
     * and update the pageload root span name on ResolveEnd.
     *
     * There's an edge case we need to avoid here: If the router fires the first navigation start event
     * _after_ the pageload root span finished. This is why we check for the pageload root span.
     * Possible real-world scenario: Angular application and/or router is bootstrapped after the pageload
     * idle root span finished
     *
     * The overall rationale is:
     * - if we already avoided creating a navigation root span once, we don't avoid it again
     *   (i.e. set `_pageloadOngoing` to `false`)
     * - if `_pageloadOngoing` is already `false`, create a navigation root span
     * - if there's no active/pageload root span, create a navigation root span
     * - only if there's an ongoing pageload root span AND `_pageloadOngoing` is still `true,
     *   don't create a navigation root span
     */
    _isPageloadOngoing() {
        if (!this._pageloadOngoing) {
            // pageload is already finished, no need to update
            return false;
        }
        const activeSpan = getActiveSpan();
        if (!activeSpan) {
            this._pageloadOngoing = false;
            return false;
        }
        const rootSpan = getRootSpan(activeSpan);
        this._pageloadOngoing = spanToJSON(rootSpan).op === 'pageload';
        return this._pageloadOngoing;
    }
}
TraceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, deps: [{ token: i1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
TraceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.Router }]; } });
const UNKNOWN_COMPONENT = 'unknown';
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
export class TraceDirective {
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit() {
        if (!this.componentName) {
            this.componentName = UNKNOWN_COMPONENT;
        }
        if (getActiveSpan()) {
            this._tracingSpan = runOutsideAngular(() => startInactiveSpan({
                name: `<${this.componentName}>`,
                op: ANGULAR_INIT_OP,
                attributes: { [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_directive' },
            }));
        }
    }
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit() {
        if (this._tracingSpan) {
            runOutsideAngular(() => this._tracingSpan.end());
        }
    }
}
TraceDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
TraceDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.3.0", type: TraceDirective, selector: "[trace]", inputs: { componentName: ["trace", "componentName"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[trace]' }]
        }], propDecorators: { componentName: [{
                type: Input,
                args: ['trace']
            }] } });
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export class TraceModule {
}
TraceModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TraceModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, declarations: [TraceDirective], exports: [TraceDirective] });
TraceModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TraceDirective],
                    exports: [TraceDirective],
                }]
        }] });
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export function TraceClass(options) {
    let tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    return target => {
        const originalOnInit = target.prototype.ngOnInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngOnInit = function (...args) {
            tracingSpan = runOutsideAngular(() => startInactiveSpan({
                onlyIfParent: true,
                name: `<${options && options.name ? options.name : 'unnamed'}>`,
                op: ANGULAR_INIT_OP,
                attributes: {
                    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_class_decorator',
                },
            }));
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        const originalAfterViewInit = target.prototype.ngAfterViewInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngAfterViewInit = function (...args) {
            if (tracingSpan) {
                runOutsideAngular(() => tracingSpan.end());
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export function TraceMethod(options) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        descriptor.value = function (...args) {
            const now = timestampInSeconds();
            runOutsideAngular(() => {
                startInactiveSpan({
                    onlyIfParent: true,
                    name: `<${options && options.name ? options.name : 'unnamed'}>`,
                    op: `${ANGULAR_OP}.${String(propertyKey)}`,
                    startTime: now,
                    attributes: {
                        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_method_decorator',
                    },
                }).end(now);
            });
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concatenated
 *
 * @returns the concatenated parameterized route string
 */
export function getParameterizedRouteFromSnapshot(route) {
    const parts = [];
    let currentRoute = route && route.firstChild;
    while (currentRoute) {
        const path = currentRoute && currentRoute.routeConfig && currentRoute.routeConfig.path;
        if (path === null || path === undefined) {
            break;
        }
        parts.push(path);
        currentRoute = currentRoute.firstChild;
    }
    const fullPath = parts.filter(part => part).join('/');
    return fullPath ? `/${fullPath}/` : '/';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFjaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFdkUsZ0hBQWdIO0FBQ2hILCtFQUErRTtBQUMvRSxzRUFBc0U7QUFDdEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBVSxNQUFNLGlCQUFpQixDQUFDO0FBQzVFLE9BQU8sRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzdFLE9BQU8sRUFDTCxnQ0FBZ0MsRUFDaEMsZ0NBQWdDLEVBQ2hDLHlCQUF5QixJQUFJLGlDQUFpQyxFQUM5RCxhQUFhLEVBQ2IsU0FBUyxFQUNULGVBQWUsRUFDZixXQUFXLEVBQ1gsVUFBVSxFQUNWLGlDQUFpQyxFQUNqQyxpQkFBaUIsR0FDbEIsTUFBTSxpQkFBaUIsQ0FBQztBQUV6QixPQUFPLEVBQUUsTUFBTSxFQUFFLHdCQUF3QixFQUFFLGtCQUFrQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXJGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3QyxPQUFPLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM5RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFFBQVEsQ0FBQzs7O0FBRTNDLElBQUksMEJBQW1DLENBQUM7QUFFeEM7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx5QkFBeUIsQ0FDdkMsVUFBbUUsRUFBRTtJQUVyRSxzRUFBc0U7SUFDdEUseUZB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O0FBQ0osQ0FBQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxVQUFVLGlDQUFpQyxDQUFDLEtBQXFDO0lBQ3JGLE1BQU0sS0FBSyxHQUFhLEVBQUUsQ0FBQztJQUUzQixJQUFJLFlBQVksR0FBRyxLQUFLLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQztJQUM3QyxPQUFPLFlBQVksRUFBRTtRQUNuQixNQUFNLElBQUksR0FBRyxZQUFZLElBQUksWUFBWSxDQUFDLFdBQVcsSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztRQUN2RixJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUN2QyxNQUFNO1NBQ1A7UUFFRCxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pCLFlBQVksR0FBRyxZQUFZLENBQUMsVUFBVSxDQUFDO0tBQ3hDO0lBRUQsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0RCxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEluamVjdGFibGUsIElucHV0LCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBFdmVudCwgUm91dGVyU3RhdGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuLy8gRHVwbGljYXRlZCBpbXBvcnQgdG8gd29yayBhcm91bmQgYSBUeXBlU2NyaXB0IGJ1ZyB3aGVyZSBpdCdkIGNvbXBsYWluIHRoYXQgYFJvdXRlcmAgaXNuJ3QgaW1wb3J0ZWQgYXMgYSB0eXBlLlxuLy8gV2UgbmVlZCB0byBpbXBvcnQgaXQgYXMgYSB2YWx1ZSB0byBzYXRpc2Z5IEFuZ3VsYXIgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvOlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtaW1wb3J0c1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNhbmNlbCwgTmF2aWdhdGlvbkVycm9yLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkVuZCwgTmF2aWdhdGlvblN0YXJ0LCBSZXNvbHZlRW5kIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7XG4gIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOLFxuICBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSxcbiAgYnJvd3NlclRyYWNpbmdJbnRlZ3JhdGlvbiBhcyBvcmlnaW5hbEJyb3dzZXJUcmFjaW5nSW50ZWdyYXRpb24sXG4gIGdldEFjdGl2ZVNwYW4sXG4gIGdldENsaWVudCxcbiAgZ2V0Q3VycmVudFNjb3BlLFxuICBnZXRSb290U3BhbixcbiAgc3BhblRvSlNPTixcbiAgc3RhcnRCcm93c2VyVHJhY2luZ05hdmlnYXRpb25TcGFuLFxuICBzdGFydEluYWN0aXZlU3Bhbixcbn0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCB0eXBlIHsgSW50ZWdyYXRpb24sIFNwYW4gfSBmcm9tICdAc2VudHJ5L3R5cGVzJztcbmltcG9ydCB7IGxvZ2dlciwgc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50LCB0aW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICdAc2VudHJ5L3V0aWxzJztcbmltcG9ydCB0eXBlIHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQU5HVUxBUl9JTklUX09QLCBBTkdVTEFSX09QLCBBTkdVTEFSX1JPVVRJTkdfT1AgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBJU19ERUJVR19CVUlMRCB9IGZyb20gJy4vZmxhZ3MnO1xuaW1wb3J0IHsgcnVuT3V0c2lkZUFuZ3VsYXIgfSBmcm9tICcuL3pvbmUnO1xuXG5sZXQgaW5zdHJ1bWVudGF0aW9uSW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbi8qKlxuICogQSBjdXN0b20gYnJvd3NlciB0cmFjaW5nIGludGVncmF0aW9uIGZvciBBbmd1bGFyLlxuICpcbiAqIFVzZSB0aGlzIGludGVncmF0aW9uIGluIGNvbWJpbmF0aW9uIHdpdGggYFRyYWNlU2VydmljZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyb3dzZXJUcmFjaW5nSW50ZWdyYXRpb24oXG4gIG9wdGlvbnM6IFBhcmFtZXRlcnM8dHlwZW9mIG9yaWdpbmFsQnJvd3NlclRyYWNpbmdJbnRlZ3JhdGlvbj5bMF0gPSB7fSxcbik6IEludGVncmF0aW9uIHtcbiAgLy8gSWYgdGhlIHVzZXIgb3B0cyBvdXQgdG8gc2V0IHRoaXMgdXAsIHdlIGp1c3QgZG9uJ3QgaW5pdGlhbGl6ZSB0aGlzLlxuICAvLyBUaGF0IHdheSwgdGhlIFRyYWNlU2VydmljZSB3aWxsIG5vdCBhY3R1YWxseSBkbyBhbnl0aGluZywgZnVuY3Rpb25hbGx5IGRpc2FibGluZyB0aGlzLlxuICBpZiAob3B0aW9ucy5pbnN0cnVtZW50TmF2aWdhdGlvbiAhPT0gZmFsc2UpIHtcbiAgICBpbnN0cnVtZW50YXRpb25Jbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gb3JpZ2luYWxCcm93c2VyVHJhY2luZ0ludGVncmF0aW9uKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGluc3RydW1lbnROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBleHRyYWN0ZWQgdG8gbWFrZSB1bml0IHRlc3RpbmcgZWFzaWVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX3VwZGF0ZVNwYW5BdHRyaWJ1dGVzRm9yUGFyYW1ldHJpemVkVXJsKHJvdXRlOiBzdHJpbmcsIHNwYW4/OiBTcGFuKTogdm9pZCB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSAoc3BhbiAmJiBzcGFuVG9KU09OKHNwYW4pLmRhdGEpIHx8IHt9O1xuXG4gIGlmIChzcGFuICYmIGF0dHJpYnV0ZXNbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdID09PSAndXJsJykge1xuICAgIHNwYW4udXBkYXRlTmFtZShyb3V0ZSk7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UsICdyb3V0ZScpO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOLCBgYXV0by4ke3NwYW5Ub0pTT04oc3Bhbikub3B9LmFuZ3VsYXJgKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZ3VsYXIncyBTZXJ2aWNlIHJlc3BvbnNpYmxlIGZvciBob29raW5nIGludG8gQW5ndWxhciBSb3V0ZXIgYW5kIHRyYWNraW5nIGN1cnJlbnQgbmF2aWdhdGlvbiBwcm9jZXNzLlxuICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiBmb3IgZXZlcnkgcm91dGUgY2hhbmdlIGFuZCBtZWFzdXJlcyBhIGR1cmF0aW9uIG9mIHJvdXRpbmcgcHJvY2Vzcy5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBUcmFjZVNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwdWJsaWMgbmF2U3RhcnQkOiBPYnNlcnZhYmxlPEV2ZW50PiA9IHRoaXMuX3JvdXRlci5ldmVudHMucGlwZShcbiAgICBmaWx0ZXIoKGV2ZW50KTogZXZlbnQgaXMgTmF2aWdhdGlvblN0YXJ0ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvblN0YXJ0KSxcbiAgICB0YXAobmF2aWdhdGlvbkV2ZW50ID0+IHtcbiAgICAgIGlmICghaW5zdHJ1bWVudGF0aW9uSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgSVNfREVCVUdfQlVJTEQgJiZcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0FuZ3VsYXIgaW50ZWdyYXRpb24gaGFzIHRyYWNpbmcgZW5hYmxlZCwgYnV0IFRyYWNpbmcgaW50ZWdyYXRpb24gaXMgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4uZW5kKCk7XG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gICAgICBjb25zdCBzdHJpcHBlZFVybCA9IHN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudChuYXZpZ2F0aW9uRXZlbnQudXJsKTtcblxuICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAvLyBzZWUgY29tbWVudCBpbiBgX2lzUGFnZWxvYWRPbmdvaW5nYCBmb3IgcmF0aW9uYWxlXG4gICAgICAgIGlmICghdGhpcy5faXNQYWdlbG9hZE9uZ29pbmcoKSkge1xuICAgICAgICAgIHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHN0YXJ0QnJvd3NlclRyYWNpbmdOYXZpZ2F0aW9uU3BhbihjbGllbnQsIHtcbiAgICAgICAgICAgICAgbmFtZTogc3RyaXBwZWRVcmwsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by5uYXZpZ2F0aW9uLmFuZ3VsYXInLFxuICAgICAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICd1cmwnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgZW5kIHVwIGhlcmUsIHdlIHNldCB0aGUgcGFnZWxvYWQgZmxhZyB0byBmYWxzZVxuICAgICAgICAgIC8vIFN1YnNlcXVlbnQgbmF2aWdhdGlvbnMgYXJlIGdvaW5nIHRvIGdldCB0aGVpciBvd24gbmF2aWdhdGlvbiByb290IHNwYW5cbiAgICAgICAgICAvLyBldmVuIGlmIHRoZSBwYWdlbG9hZCByb290IHNwYW4gaXMgc3RpbGwgb25nb2luZy5cbiAgICAgICAgICB0aGlzLl9wYWdlbG9hZE9uZ29pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuID1cbiAgICAgICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICAgICAgc3RhcnRJbmFjdGl2ZVNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBgJHtuYXZpZ2F0aW9uRXZlbnQudXJsfWAsXG4gICAgICAgICAgICAgIG9wOiBBTkdVTEFSX1JPVVRJTkdfT1AsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by51aS5hbmd1bGFyJyxcbiAgICAgICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiAndXJsJyxcbiAgICAgICAgICAgICAgICB1cmw6IHN0cmlwcGVkVXJsLFxuICAgICAgICAgICAgICAgIC4uLihuYXZpZ2F0aW9uRXZlbnQubmF2aWdhdGlvblRyaWdnZXIgJiYge1xuICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvblRyaWdnZXI6IG5hdmlnYXRpb25FdmVudC5uYXZpZ2F0aW9uVHJpZ2dlcixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICkgfHwgbnVsbDtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSksXG4gICk7XG5cbiAgLy8gVGhlIFJlc29sdmVFbmQgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgQW5ndWxhciByb3V0ZXIgaGFzIHJlc29sdmVkIHRoZSBVUkwgYW5kXG4gIC8vIHRoZSBwYXJhbWV0ZXI8LT52YWx1ZSBtYXBwaW5nLiBJdCBob2xkcyB0aGUgbmV3IHJlc29sdmVkIHJvdXRlciBzdGF0ZSB3aXRoXG4gIC8vIHRoZSBtYXBwaW5nIGFuZCB0aGUgbmV3IFVSTC5cbiAgLy8gT25seSBBZnRlciB0aGlzIGV2ZW50LCB0aGUgcm91dGUgaXMgYWN0aXZhdGVkLCBtZWFuaW5nIHRoYXQgdGhlIHRyYW5zYWN0aW9uXG4gIC8vIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIHBhcmFtZXRlcml6ZWQgcm91dGUgbmFtZSBiZWZvcmUgZS5nLiB0aGUgcm91dGUncyByb290XG4gIC8vIGNvbXBvbmVudCBpcyBpbml0aWFsaXplZC4gVGhpcyBzaG91bGQgYmUgZWFybHkgZW5vdWdoIGJlZm9yZSBvdXRnb2luZyByZXF1ZXN0c1xuICAvLyBhcmUgbWFkZSBmcm9tIHRoZSBuZXcgcm91dGUsIHdpdGggdGhlIGV4Y2VwdGlvbnMgb2YgcmVxdWVzdHMgYmVpbmcgbWFkZSBkdXJpbmdcbiAgLy8gYSBuYXZpZ2F0aW9uLlxuICBwdWJsaWMgcmVzRW5kJDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCk6IGV2ZW50IGlzIFJlc29sdmVFbmQgPT4gZXZlbnQgaW5zdGFuY2VvZiBSZXNvbHZlRW5kKSxcbiAgICB0YXAoZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgcm91dGUgPSBnZXRQYXJhbWV0ZXJpemVkUm91dGVGcm9tU25hcHNob3QoXG4gICAgICAgIChldmVudC5zdGF0ZSBhcyB1bmtub3duIGFzIFJvdXRlclN0YXRlICYgeyByb290OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IH0pLnJvb3QsXG4gICAgICApO1xuXG4gICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgZ2V0Q3VycmVudFNjb3BlKCkuc2V0VHJhbnNhY3Rpb25OYW1lKHJvdXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aXZlU3BhbiA9IGdldEFjdGl2ZVNwYW4oKTtcbiAgICAgIGNvbnN0IHJvb3RTcGFuID0gYWN0aXZlU3BhbiAmJiBnZXRSb290U3BhbihhY3RpdmVTcGFuKTtcblxuICAgICAgX3VwZGF0ZVNwYW5BdHRyaWJ1dGVzRm9yUGFyYW1ldHJpemVkVXJsKHJvdXRlLCByb290U3Bhbik7XG4gICAgfSksXG4gICk7XG5cbiAgcHVibGljIG5hdkVuZCQ6IE9ic2VydmFibGU8RXZlbnQ+ID0gdGhpcy5fcm91dGVyLmV2ZW50cy5waXBlKFxuICAgIGZpbHRlcihcbiAgICAgIGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCB8fCBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25DYW5jZWwgfHwgZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRXJyb3IsXG4gICAgKSxcbiAgICB0YXAoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3JvdXRpbmdTcGFuKSB7XG4gICAgICAgIHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuIS5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KSxcbiAgKTtcblxuICBwcml2YXRlIF9yb3V0aW5nU3BhbjogU3BhbiB8IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIEBzZWUgX2lzUGFnZWxvYWRPbmdvaW5nKClcbiAgICovXG4gIHByaXZhdGUgX3BhZ2Vsb2FkT25nb2luZzogYm9vbGVhbjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBfcm91dGVyOiBSb3V0ZXIpIHtcbiAgICB0aGlzLl9yb3V0aW5nU3BhbiA9IG51bGw7XG4gICAgdGhpcy5fcGFnZWxvYWRPbmdvaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5uYXZTdGFydCQuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5yZXNFbmQkLnN1YnNjcmliZSgpKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHRoaXMubmF2RW5kJC5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIHdoZW4gdGhlIHJvb3QgdmlldyBpcyBjcmVhdGVkIGFuZCBkZXN0cm95ZWQgbXVsdGlwbGUgdGltZXMsXG4gICAqIHNpbmNlIGBzdWJzY3JpYmVgIGNhbGxiYWNrcyBjYXB0dXJlIGB0aGlzYCBhbmQgcHJldmVudCBtYW55IHJlc291cmNlcyBmcm9tIGJlaW5nIEdDJ2QuXG4gICAqL1xuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogV2Ugb25seSBfYXZvaWRfIGNyZWF0aW5nIGEgbmF2aWdhdGlvbiByb290IHNwYW4gaW4gb25lIGNhc2U6XG4gICAqXG4gICAqIFRoZXJlIGlzIGFuIG9uZ29pbmcgcGFnZWxvYWQgc3BhbiBBTkQgdGhlIHJvdXRlciBkaWRuJ3QgeWV0IGVtaXQgdGhlIGZpcnN0IG5hdmlnYXRpb24gc3RhcnQgZXZlbnRcbiAgICpcbiAgICogVGhlIGZpcnN0IG5hdmlnYXRpb24gc3RhcnQgZXZlbnQgd2lsbCBjcmVhdGUgdGhlIGNoaWxkIHJvdXRpbmcgc3BhblxuICAgKiBhbmQgdXBkYXRlIHRoZSBwYWdlbG9hZCByb290IHNwYW4gbmFtZSBvbiBSZXNvbHZlRW5kLlxuICAgKlxuICAgKiBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3ZSBuZWVkIHRvIGF2b2lkIGhlcmU6IElmIHRoZSByb3V0ZXIgZmlyZXMgdGhlIGZpcnN0IG5hdmlnYXRpb24gc3RhcnQgZXZlbnRcbiAgICogX2FmdGVyXyB0aGUgcGFnZWxvYWQgcm9vdCBzcGFuIGZpbmlzaGVkLiBUaGlzIGlzIHdoeSB3ZSBjaGVjayBmb3IgdGhlIHBhZ2Vsb2FkIHJvb3Qgc3Bhbi5cbiAgICogUG9zc2libGUgcmVhbC13b3JsZCBzY2VuYXJpbzogQW5ndWxhciBhcHBsaWNhdGlvbiBhbmQvb3Igcm91dGVyIGlzIGJvb3RzdHJhcHBlZCBhZnRlciB0aGUgcGFnZWxvYWRcbiAgICogaWRsZSByb290IHNwYW4gZmluaXNoZWRcbiAgICpcbiAgICogVGhlIG92ZXJhbGwgcmF0aW9uYWxlIGlzOlxuICAgKiAtIGlmIHdlIGFscmVhZHkgYXZvaWRlZCBjcmVhdGluZyBhIG5hdmlnYXRpb24gcm9vdCBzcGFuIG9uY2UsIHdlIGRvbid0IGF2b2lkIGl0IGFnYWluXG4gICAqICAgKGkuZS4gc2V0IGBfcGFnZWxvYWRPbmdvaW5nYCB0byBgZmFsc2VgKVxuICAgKiAtIGlmIGBfcGFnZWxvYWRPbmdvaW5nYCBpcyBhbHJlYWR5IGBmYWxzZWAsIGNyZWF0ZSBhIG5hdmlnYXRpb24gcm9vdCBzcGFuXG4gICAqIC0gaWYgdGhlcmUncyBubyBhY3RpdmUvcGFnZWxvYWQgcm9vdCBzcGFuLCBjcmVhdGUgYSBuYXZpZ2F0aW9uIHJvb3Qgc3BhblxuICAgKiAtIG9ubHkgaWYgdGhlcmUncyBhbiBvbmdvaW5nIHBhZ2Vsb2FkIHJvb3Qgc3BhbiBBTkQgYF9wYWdlbG9hZE9uZ29pbmdgIGlzIHN0aWxsIGB0cnVlLFxuICAgKiAgIGRvbid0IGNyZWF0ZSBhIG5hdmlnYXRpb24gcm9vdCBzcGFuXG4gICAqL1xuICBwcml2YXRlIF9pc1BhZ2Vsb2FkT25nb2luZygpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuX3BhZ2Vsb2FkT25nb2luZykge1xuICAgICAgLy8gcGFnZWxvYWQgaXMgYWxyZWFkeSBmaW5pc2hlZCwgbm8gbmVlZCB0byB1cGRhdGVcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVTcGFuID0gZ2V0QWN0aXZlU3BhbigpO1xuICAgIGlmICghYWN0aXZlU3Bhbikge1xuICAgICAgdGhpcy5fcGFnZWxvYWRPbmdvaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdFNwYW4gPSBnZXRSb290U3BhbihhY3RpdmVTcGFuKTtcblxuICAgIHRoaXMuX3BhZ2Vsb2FkT25nb2luZyA9IHNwYW5Ub0pTT04ocm9vdFNwYW4pLm9wID09PSAncGFnZWxvYWQnO1xuICAgIHJldHVybiB0aGlzLl9wYWdlbG9hZE9uZ29pbmc7XG4gIH1cbn1cblxuY29uc3QgVU5LTk9XTl9DT01QT05FTlQgPSAndW5rbm93bic7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGluaXRpYWxpemF0aW9uIGxpZmVjeWNsZSBvZiB0aGUgd2hvbGUgY29tcG9uZW50LlxuICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbdHJhY2VdJyB9KVxuZXhwb3J0IGNsYXNzIFRyYWNlRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0IHtcbiAgQElucHV0KCd0cmFjZScpIHB1YmxpYyBjb21wb25lbnROYW1lPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgX3RyYWNpbmdTcGFuPzogU3BhbjtcblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgT25Jbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29tcG9uZW50TmFtZSkge1xuICAgICAgdGhpcy5jb21wb25lbnROYW1lID0gVU5LTk9XTl9DT01QT05FTlQ7XG4gICAgfVxuXG4gICAgaWYgKGdldEFjdGl2ZVNwYW4oKSkge1xuICAgICAgdGhpcy5fdHJhY2luZ1NwYW4gPSBydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICBzdGFydEluYWN0aXZlU3Bhbih7XG4gICAgICAgICAgbmFtZTogYDwke3RoaXMuY29tcG9uZW50TmFtZX0+YCxcbiAgICAgICAgICBvcDogQU5HVUxBUl9JTklUX09QLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogJ2F1dG8udWkuYW5ndWxhci50cmFjZV9kaXJlY3RpdmUnIH0sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgQWZ0ZXJWaWV3SW5pdCBsaWZlY3ljbGUgbWV0aG9kXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl90cmFjaW5nU3Bhbikge1xuICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5fdHJhY2luZ1NwYW4hLmVuZCgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIG1vZHVsZSBzZXJ2ZXMgYXMgYSBzaW5nbGUgY29tcGlsYXRpb24gdW5pdCBmb3IgdGhlIGBUcmFjZURpcmVjdGl2ZWAgYW5kIGNhbiBiZSByZS11c2VkIGJ5IGFueSBvdGhlciBtb2R1bGUuXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1RyYWNlRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1RyYWNlRGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJhY2VNb2R1bGUge31cblxuaW50ZXJmYWNlIFRyYWNlQ2xhc3NPcHRpb25zIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNsYXNzXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhcHR1cmUgaW5pdGlhbGl6YXRpb24gbGlmZWN5Y2xlIG9mIHRoZSB3aG9sZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUcmFjZUNsYXNzKG9wdGlvbnM/OiBUcmFjZUNsYXNzT3B0aW9ucyk6IENsYXNzRGVjb3JhdG9yIHtcbiAgbGV0IHRyYWNpbmdTcGFuOiBTcGFuO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAqL1xuICByZXR1cm4gdGFyZ2V0ID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbE9uSW5pdCA9IHRhcmdldC5wcm90b3R5cGUubmdPbkluaXQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0YXJnZXQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxPbkluaXQ+IHtcbiAgICAgIHRyYWNpbmdTcGFuID0gcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgc3RhcnRJbmFjdGl2ZVNwYW4oe1xuICAgICAgICAgIG9ubHlJZlBhcmVudDogdHJ1ZSxcbiAgICAgICAgICBuYW1lOiBgPCR7b3B0aW9ucyAmJiBvcHRpb25zLm5hbWUgPyBvcHRpb25zLm5hbWUgOiAndW5uYW1lZCd9PmAsXG4gICAgICAgICAgb3A6IEFOR1VMQVJfSU5JVF9PUCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by51aS5hbmd1bGFyLnRyYWNlX2NsYXNzX2RlY29yYXRvcicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICBpZiAob3JpZ2luYWxPbkluaXQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25Jbml0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvcmlnaW5hbEFmdGVyVmlld0luaXQgPSB0YXJnZXQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRhcmdldC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxBZnRlclZpZXdJbml0PiB7XG4gICAgICBpZiAodHJhY2luZ1NwYW4pIHtcbiAgICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdHJhY2luZ1NwYW4uZW5kKCkpO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsQWZ0ZXJWaWV3SW5pdCkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxBZnRlclZpZXdJbml0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzICovXG59XG5cbmludGVyZmFjZSBUcmFjZU1ldGhvZE9wdGlvbnMge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgbWV0aG9kIChpcyBhZGRlZCB0byB0aGUgdHJhY2luZyBzcGFuKVxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGEgc2luZ2xlIGxpZmVjeWNsZSBtZXRob2RzIG9mIHRoZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUcmFjZU1ldGhvZChvcHRpb25zPzogVHJhY2VNZXRob2RPcHRpb25zKTogTWV0aG9kRGVjb3JhdG9yIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgcmV0dXJuICh0YXJnZXQ6IE9iamVjdCwgcHJvcGVydHlLZXk6IHN0cmluZyB8IHN5bWJvbCwgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSk6IFJldHVyblR5cGU8dHlwZW9mIG9yaWdpbmFsTWV0aG9kPiB7XG4gICAgICBjb25zdCBub3cgPSB0aW1lc3RhbXBJblNlY29uZHMoKTtcblxuICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICBzdGFydEluYWN0aXZlU3Bhbih7XG4gICAgICAgICAgb25seUlmUGFyZW50OiB0cnVlLFxuICAgICAgICAgIG5hbWU6IGA8JHtvcHRpb25zICYmIG9wdGlvbnMubmFtZSA/IG9wdGlvbnMubmFtZSA6ICd1bm5hbWVkJ30+YCxcbiAgICAgICAgICBvcDogYCR7QU5HVUxBUl9PUH0uJHtTdHJpbmcocHJvcGVydHlLZXkpfWAsXG4gICAgICAgICAgc3RhcnRUaW1lOiBub3csXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogJ2F1dG8udWkuYW5ndWxhci50cmFjZV9tZXRob2RfZGVjb3JhdG9yJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KS5lbmQobm93KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3JpZ2luYWxNZXRob2QpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgcGFyYW1ldGVyaXplZCByb3V0ZSBmcm9tIGEgZ2l2ZW4gQWN0aXZhdGVkUm91dGVTbmFwc2hvdCBhbmQgY29uY2F0ZW5hdGVzIHRoZSBzbmFwc2hvdCdzXG4gKiBjaGlsZCByb3V0ZSB3aXRoIGl0cyBwYXJlbnQgdG8gcHJvZHVjZSB0aGUgY29tcGxldGUgcGFyYW1ldGVyaXplZCBVUkwgb2YgdGhlIGFjdGl2YXRlZCByb3V0ZS5cbiAqIFRoaXMgaGFwcGVucyByZWN1cnNpdmVseSB1bnRpbCB0aGUgbGFzdCBjaGlsZCAoaS5lLiB0aGUgZW5kIG9mIHRoZSBVUkwpIGlzIHJlYWNoZWQuXG4gKlxuICogQHBhcmFtIHJvdXRlIHRoZSBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IG9mIHdoaWNoIGl0cyBwYXRoIGFuZCBpdHMgY2hpbGQncyBwYXRoIGlzIGNvbmNhdGVuYXRlZFxuICpcbiAqIEByZXR1cm5zIHRoZSBjb25jYXRlbmF0ZWQgcGFyYW1ldGVyaXplZCByb3V0ZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtZXRlcml6ZWRSb3V0ZUZyb21TbmFwc2hvdChyb3V0ZT86IEFjdGl2YXRlZFJvdXRlU25hcHNob3QgfCBudWxsKTogc3RyaW5nIHtcbiAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gW107XG5cbiAgbGV0IGN1cnJlbnRSb3V0ZSA9IHJvdXRlICYmIHJvdXRlLmZpcnN0Q2hpbGQ7XG4gIHdoaWxlIChjdXJyZW50Um91dGUpIHtcbiAgICBjb25zdCBwYXRoID0gY3VycmVudFJvdXRlICYmIGN1cnJlbnRSb3V0ZS5yb3V0ZUNvbmZpZyAmJiBjdXJyZW50Um91dGUucm91dGVDb25maWcucGF0aDtcbiAgICBpZiAocGF0aCA9PT0gbnVsbCB8fCBwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2gocGF0aCk7XG4gICAgY3VycmVudFJvdXRlID0gY3VycmVudFJvdXRlLmZpcnN0Q2hpbGQ7XG4gIH1cblxuICBjb25zdCBmdWxsUGF0aCA9IHBhcnRzLmZpbHRlcihwYXJ0ID0+IHBhcnQpLmpvaW4oJy8nKTtcbiAgcmV0dXJuIGZ1bGxQYXRoID8gYC8ke2Z1bGxQYXRofS9gIDogJy8nO1xufVxuIl19